---
title: "R Notebook"
output: html_notebook
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)

# Load packages
#install.packages("tidyr")
library(tidyr)
#install.packages("tidyverse")
library(tidyverse)
#install.packages("readr")
library(readr)
#install.packages("PortfolioAnalytics")
library(PortfolioAnalytics)
#install.packages("ROI")
library(ROI)
#install.packages("ROI.plugin.quadprog")
library(ROI.plugin.quadprog)
#install.packages("ROI.plugin.glpk")
library(ROI.plugin.glpk)
#install.packages('quantmod')
#install.packages('TTR')
library('TTR')
library('quantmod')

library(PerformanceAnalytics)
library(quantmod)
#install.packages("tidyquant")
library(tidyquant)
library(xts) 
library(ggplot2)
#install.packages("highcharter")
library(highcharter)
library(purrr)
library(dplyr)
#install.packages("fredr")
library(fredr)
#install.packages("FSA")
library(FSA)
library(fPortfolio)

library(quadprog)  
library(robust)
#library(fields)

start_date = "2015-01-01"
end_date = "2020-12-31"
```




ticker = c( "NVDA", "TSMC", "005930.KS", "AVGO", "ASML", "AMD", "QCOM", "AMAT", "ADI", "LRCX", "MU", "WMT", "PG", "KO", "COST")
```{r}
ticker = c( "NVDA", "TSMC", "005930.KS", "AVGO", "ASML", "AMD", "QCOM", "AMAT", "ADI", "LRCX", "MU", "WMT", "PG", "KO", "COST")
length(ticker)
```


1. Fred Data
```{r}
#API Key = 75711c32cc2177d3a651e1cef5d26d6a
fredr_set_key("75711c32cc2177d3a651e1cef5d26d6a")

# Consumer Price Index for All Urban Consumers: All Items in U.S. City Average (CPIAUCSL)	

CPIAUCSL <- fredr(
  series_id = "CPIAUCSL",
  observation_start = as.Date(start_date),
  observation_end = as.Date(end_date),
  frequency = "m"
)

cpi = subset(CPIAUCSL , select = c(value, date))

ts_cpi = as.xts(cpi)
chart_Series(ts_cpi , name="CPI")
```

inflations
```{r}
inflation_rate <- diff(ts_cpi) /lag(ts_cpi, k = -1)
chart_Series(inflation_rate, name="inflation_rate")
```


target
```{r}
performance_target <- inflation_rate + 3
chart_Series(performance_target, name="performance_target")
```




```{r}

df_spy = getSymbols("SPY", from = "2014-01-01", to = end_date, auto.assign = FALSE)

spy_prices = as.xts(df_spy$SPY.Close)
spy_log_prices <- diff(log(spy_prices), lag=1)
spy_rolling_sd <- na.omit(rollapply(spy_log_prices, 126, function(x) StdDev(x)))
spy_rolling_sd = window(spy_rolling_sd, start = start_date, end = end_date)

chart_Series(spy_rolling_sd , name="spy_rolling_sd")

```


```{r}
loss_threshold = -8*spy_rolling_sd
chart_Series(loss_threshold , name="spy_rolling_sd")
```



```{r}

asset_weight <- function(symbol, s_date, e_date){
  # 6 month prior calculation
  s_date_prior = as.Date(s_date) %m-% months(6)
  e_date_prior = as.Date(s_date)
  
  #get assets
  df_Assets <- getSymbols(symbol, from = s_date_prior, to = e_date_prior)

  # Storing the prices in one array
  prices <- purrr::map(symbol, function(x) Ad(get(x)))
  prices <- purrr::reduce(prices, merge)
  colnames(prices) <- symbol
  
  
  # Computing daily returns
  rt_daily <- na.omit(Return.calculate(prices, method = "log"))

  
  # Covariance and Mean estimates  
  sampCovRobMCD <- covRob(rt_daily, estim = "mcd", quan = .95, ntrial = 10000)
  mu <- sampCovRobMCD$center
  varcov <- sampCovRobMCD$cov
  
  # Number of assets
  nvar <- length(mu)
  
  # Number of efficient frontier points
  n.er <- 100  
  rset <- seq(min(mu), max(mu), length=n.er+2)
  rset <- rset[2:n.er+1]
  
  # Initialize variables to store results
  port.ret <- rset
  port.std <- rset*0
  port.wgt <- matrix(0, n.er, nvar)
  
  # Calculate efficient frontier using quadratic programming
  for (i in 1:(n.er-1)) {
  Dmat <- 2*varcov
  dvec <- rep(0, nvar) 
  Amat <- t(rbind(t(rep(1, nvar)), t(mu), diag(nvar)))
  bvec <- c(1, rset[i], rep(0, nvar))
  
  # Mean-variance optimization
  m <- solve.QP(Dmat, dvec, Amat, bvec, meq = 2)
  
  # Store results
  port.std[i]  <- sqrt(m$value)
  port.wgt[i,] <- t(m$solution)
  }
  
  # Efficient frontier 
  plot(sqrt(diag(varcov)), mu, xlim=c(0.8*min(port.std),1.6*max(port.std)), 
     ylim=c(1.2*min(mu), 1.2*max(mu)), col = rainbow(nvar), lwd = 10, 
     xlab = expression(sigma), ylab = expression(mu))
  text(sqrt(diag(varcov)), mu, labels = tickers, cex= 1)
  lines(port.std, port.ret, col = "black", lwd = 1)

}

```


Stocks 

Nvidia: "NVDA"
Apple "AAPL"
Google: "GOOG"
Microsoft: "MSFT"
Intel: "INTC"
IBM: "IMB"
SAP: "SAP
Amazon: "AMZN"
Oracle: "ORCL"
Analog Devices: "ADI"
3D Systems Corporation: "DDD"

"NVDA", "AAPL", "GOOG", "MSFT", "INTC", "IMB", "SAP", "AMZN", "ORCL", "ADI", "DDD"





Daily Returns
```{r}

tickers = c( "NVDA", "TSM", "005930.KS", "AVGO", "ASML", "AMD", "QCOM", "AMAT", "ADI", "LRCX", "MU", "WMT", "PG", "KO", "COST")
asset_weight(tickers, start_date, end_date)


```


pr_daily <- getSymbols(tickers, src = "yahoo",
           from = start_date,
           to = end_date,
           auto.assign = TRUE) %>% 
  map(~Ad(get(.))) %>% 
  reduce(merge)

pr_daily = as.xts(pr_daily)
```

Daily Log Returns
```{r}
rt_daily <- na.omit(Return.calculate(pr_daily, method = "log"))
head(rt_daily)

```

Constrained Portfolio
```{r}

# Create Portfolio object which is essentially a list object
high_exp_return_portfolio <- PortfolioAnalytics::portfolio.spec(assets = tickers)
typeof(high_var_portfolio)


high_exp_return_portfolio <- PortfolioAnalytics::add.constraint(
  portfolio = high_exp_return_portfolio,
  type = "full_investment"
)

high_exp_return_portfolio <- PortfolioAnalytics::add.constraint(
  portfolio = high_exp_return_portfolio,
  type = "long_only"
)

high_exp_return_portfolio <- PortfolioAnalytics::add.constraint(
  portfolio = high_exp_return_portfolio,
  type = "transaction_cost", ptc = .1
)

#expected valua
high_exp_return_portfolio <- PortfolioAnalytics::add.constraint(
  portfolio = high_exp_return_portfolio,
  type = "transaction_cost", ptc = .1
)


# Add objective to minimize variance
high_exp_return_portfolio <- PortfolioAnalytics::add.objective(
  portfolio = high_exp_return_portfolio,
  type = "return",
  name = "mean"
)

```

max portfolio
```{r , echo = TRUE}

global_max_portfolio <- PortfolioAnalytics::optimize.portfolio(
  R = rt_daily,
  portfolio = high_exp_return_portfolio,
  # This defaults to the "glpk" solver
  optimize_method = "glpk",
  # Return additional information on the path or portfolios searched
  trace = TRUE
)
# Examine returned portfolio list object
global_max_portfolio


```


```{r Markowitz 5, echo = TRUE}

# Set optimal weights
weights <- pluck(.x = global_max_portfolio, "weights")
# Check if the weights and symbols align
tibble(weights, tickers)

```

```{r Markowitz 6, echo = TRUE}

# Ensure that the weights vector sums up to 1
tibble(weights, tickers) %>%
  dplyr::summarize(total_weight = sum(weights))


```



```{r Markowitz 8, echo = TRUE}

# Compute monthly portfolio returns
portfolio_returns_xts_rebalanced <-
  PerformanceAnalytics::Return.portfolio(
    R = rt_daily,
    weights = weights,
    # Monthly re-balancing
    reblance_on = "yearly",
    # Use simple/arithmetic chaining to aggregate returns
    geometric = FALSE
  ) %>%
  `colnames<-`("portfolio_returns")
# Examine
head(portfolio_returns_xts_rebalanced, 5)

```
```{r}

chart_Series(portfolio_returns_xts_rebalanced , name="Portfolio Returns")

```







```{r}
portfolio_returns_xts_rebalanced <-
  PerformanceAnalytics::Return.portfolio(
    R = pr_daily,
    weights = weights,
    # Monthly re-balancing
    reblance_on = "yearly",
    # Use simple/arithmetic chaining to aggregate returns
    geometric = FALSE
  ) %>%
  `colnames<-`("portfolio_returns")
# Examine
head(portfolio_returns_xts_rebalanced, 5)

chart_Series(portfolio_returns_xts_rebalanced , name="Portfolio Returns")
```






